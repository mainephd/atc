// This file was generated by counterfeiter
package dbngfakes

import (
	"encoding/json"
	"sync"
	"time"

	"github.com/concourse/atc"
	"github.com/concourse/atc/dbng"
)

type FakeTeam struct {
	IDStub        func() int
	iDMutex       sync.RWMutex
	iDArgsForCall []struct{}
	iDReturns     struct {
		result1 int
	}
	iDReturnsOnCall map[int]struct {
		result1 int
	}
	NameStub        func() string
	nameMutex       sync.RWMutex
	nameArgsForCall []struct{}
	nameReturns     struct {
		result1 string
	}
	nameReturnsOnCall map[int]struct {
		result1 string
	}
	AdminStub        func() bool
	adminMutex       sync.RWMutex
	adminArgsForCall []struct{}
	adminReturns     struct {
		result1 bool
	}
	adminReturnsOnCall map[int]struct {
		result1 bool
	}
	BasicAuthStub        func() *atc.BasicAuth
	basicAuthMutex       sync.RWMutex
	basicAuthArgsForCall []struct{}
	basicAuthReturns     struct {
		result1 *atc.BasicAuth
	}
	basicAuthReturnsOnCall map[int]struct {
		result1 *atc.BasicAuth
	}
	AuthStub        func() map[string]*json.RawMessage
	authMutex       sync.RWMutex
	authArgsForCall []struct{}
	authReturns     struct {
		result1 map[string]*json.RawMessage
	}
	authReturnsOnCall map[int]struct {
		result1 map[string]*json.RawMessage
	}
	SavePipelineStub        func(pipelineName string, config atc.Config, from dbng.ConfigVersion, pausedState dbng.PipelinePausedState) (dbng.Pipeline, bool, error)
	savePipelineMutex       sync.RWMutex
	savePipelineArgsForCall []struct {
		pipelineName string
		config       atc.Config
		from         dbng.ConfigVersion
		pausedState  dbng.PipelinePausedState
	}
	savePipelineReturns struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}
	savePipelineReturnsOnCall map[int]struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}
	FindPipelineByNameStub        func(pipelineName string) (dbng.Pipeline, bool, error)
	findPipelineByNameMutex       sync.RWMutex
	findPipelineByNameArgsForCall []struct {
		pipelineName string
	}
	findPipelineByNameReturns struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}
	findPipelineByNameReturnsOnCall map[int]struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}
	CreateOneOffBuildStub        func() (dbng.Build, error)
	createOneOffBuildMutex       sync.RWMutex
	createOneOffBuildArgsForCall []struct{}
	createOneOffBuildReturns     struct {
		result1 dbng.Build
		result2 error
	}
	createOneOffBuildReturnsOnCall map[int]struct {
		result1 dbng.Build
		result2 error
	}
	SaveWorkerStub        func(atcWorker atc.Worker, ttl time.Duration) (dbng.Worker, error)
	saveWorkerMutex       sync.RWMutex
	saveWorkerArgsForCall []struct {
		atcWorker atc.Worker
		ttl       time.Duration
	}
	saveWorkerReturns struct {
		result1 dbng.Worker
		result2 error
	}
	saveWorkerReturnsOnCall map[int]struct {
		result1 dbng.Worker
		result2 error
	}
	WorkersStub        func() ([]dbng.Worker, error)
	workersMutex       sync.RWMutex
	workersArgsForCall []struct{}
	workersReturns     struct {
		result1 []dbng.Worker
		result2 error
	}
	workersReturnsOnCall map[int]struct {
		result1 []dbng.Worker
		result2 error
	}
	FindContainerByHandleStub        func(string) (dbng.Container, bool, error)
	findContainerByHandleMutex       sync.RWMutex
	findContainerByHandleArgsForCall []struct {
		arg1 string
	}
	findContainerByHandleReturns struct {
		result1 dbng.Container
		result2 bool
		result3 error
	}
	findContainerByHandleReturnsOnCall map[int]struct {
		result1 dbng.Container
		result2 bool
		result3 error
	}
	FindContainersByMetadataStub        func(dbng.ContainerMetadata) ([]dbng.Container, error)
	findContainersByMetadataMutex       sync.RWMutex
	findContainersByMetadataArgsForCall []struct {
		arg1 dbng.ContainerMetadata
	}
	findContainersByMetadataReturns struct {
		result1 []dbng.Container
		result2 error
	}
	findContainersByMetadataReturnsOnCall map[int]struct {
		result1 []dbng.Container
		result2 error
	}
	FindCreatedContainerByHandleStub        func(string) (dbng.CreatedContainer, bool, error)
	findCreatedContainerByHandleMutex       sync.RWMutex
	findCreatedContainerByHandleArgsForCall []struct {
		arg1 string
	}
	findCreatedContainerByHandleReturns struct {
		result1 dbng.CreatedContainer
		result2 bool
		result3 error
	}
	findCreatedContainerByHandleReturnsOnCall map[int]struct {
		result1 dbng.CreatedContainer
		result2 bool
		result3 error
	}
	FindWorkerForResourceCheckContainerStub        func(resourceConfig *dbng.UsedResourceConfig) (dbng.Worker, bool, error)
	findWorkerForResourceCheckContainerMutex       sync.RWMutex
	findWorkerForResourceCheckContainerArgsForCall []struct {
		resourceConfig *dbng.UsedResourceConfig
	}
	findWorkerForResourceCheckContainerReturns struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}
	findWorkerForResourceCheckContainerReturnsOnCall map[int]struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}
	FindResourceCheckContainerOnWorkerStub        func(workerName string, resourceConfig *dbng.UsedResourceConfig) (dbng.CreatingContainer, dbng.CreatedContainer, error)
	findResourceCheckContainerOnWorkerMutex       sync.RWMutex
	findResourceCheckContainerOnWorkerArgsForCall []struct {
		workerName     string
		resourceConfig *dbng.UsedResourceConfig
	}
	findResourceCheckContainerOnWorkerReturns struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}
	findResourceCheckContainerOnWorkerReturnsOnCall map[int]struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}
	CreateResourceCheckContainerStub        func(workerName string, resourceConfig *dbng.UsedResourceConfig, meta dbng.ContainerMetadata) (dbng.CreatingContainer, error)
	createResourceCheckContainerMutex       sync.RWMutex
	createResourceCheckContainerArgsForCall []struct {
		workerName     string
		resourceConfig *dbng.UsedResourceConfig
		meta           dbng.ContainerMetadata
	}
	createResourceCheckContainerReturns struct {
		result1 dbng.CreatingContainer
		result2 error
	}
	createResourceCheckContainerReturnsOnCall map[int]struct {
		result1 dbng.CreatingContainer
		result2 error
	}
	CreateResourceGetContainerStub        func(workerName string, resourceConfig *dbng.UsedResourceCache, meta dbng.ContainerMetadata) (dbng.CreatingContainer, error)
	createResourceGetContainerMutex       sync.RWMutex
	createResourceGetContainerArgsForCall []struct {
		workerName     string
		resourceConfig *dbng.UsedResourceCache
		meta           dbng.ContainerMetadata
	}
	createResourceGetContainerReturns struct {
		result1 dbng.CreatingContainer
		result2 error
	}
	createResourceGetContainerReturnsOnCall map[int]struct {
		result1 dbng.CreatingContainer
		result2 error
	}
	FindWorkerForContainerStub        func(handle string) (dbng.Worker, bool, error)
	findWorkerForContainerMutex       sync.RWMutex
	findWorkerForContainerArgsForCall []struct {
		handle string
	}
	findWorkerForContainerReturns struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}
	findWorkerForContainerReturnsOnCall map[int]struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}
	FindWorkerForBuildContainerStub        func(buildID int, planID atc.PlanID) (dbng.Worker, bool, error)
	findWorkerForBuildContainerMutex       sync.RWMutex
	findWorkerForBuildContainerArgsForCall []struct {
		buildID int
		planID  atc.PlanID
	}
	findWorkerForBuildContainerReturns struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}
	findWorkerForBuildContainerReturnsOnCall map[int]struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}
	FindBuildContainerOnWorkerStub        func(workerName string, buildID int, planID atc.PlanID) (dbng.CreatingContainer, dbng.CreatedContainer, error)
	findBuildContainerOnWorkerMutex       sync.RWMutex
	findBuildContainerOnWorkerArgsForCall []struct {
		workerName string
		buildID    int
		planID     atc.PlanID
	}
	findBuildContainerOnWorkerReturns struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}
	findBuildContainerOnWorkerReturnsOnCall map[int]struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}
	CreateBuildContainerStub        func(workerName string, buildID int, planID atc.PlanID, meta dbng.ContainerMetadata) (dbng.CreatingContainer, error)
	createBuildContainerMutex       sync.RWMutex
	createBuildContainerArgsForCall []struct {
		workerName string
		buildID    int
		planID     atc.PlanID
		meta       dbng.ContainerMetadata
	}
	createBuildContainerReturns struct {
		result1 dbng.CreatingContainer
		result2 error
	}
	createBuildContainerReturnsOnCall map[int]struct {
		result1 dbng.CreatingContainer
		result2 error
	}
	UpdateBasicAuthStub        func(basicAuth *atc.BasicAuth) error
	updateBasicAuthMutex       sync.RWMutex
	updateBasicAuthArgsForCall []struct {
		basicAuth *atc.BasicAuth
	}
	updateBasicAuthReturns struct {
		result1 error
	}
	updateBasicAuthReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateProviderAuthStub        func(auth map[string]*json.RawMessage) error
	updateProviderAuthMutex       sync.RWMutex
	updateProviderAuthArgsForCall []struct {
		auth map[string]*json.RawMessage
	}
	updateProviderAuthReturns struct {
		result1 error
	}
	updateProviderAuthReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeTeam) ID() int {
	fake.iDMutex.Lock()
	ret, specificReturn := fake.iDReturnsOnCall[len(fake.iDArgsForCall)]
	fake.iDArgsForCall = append(fake.iDArgsForCall, struct{}{})
	fake.recordInvocation("ID", []interface{}{})
	fake.iDMutex.Unlock()
	if fake.IDStub != nil {
		return fake.IDStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.iDReturns.result1
}

func (fake *FakeTeam) IDCallCount() int {
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	return len(fake.iDArgsForCall)
}

func (fake *FakeTeam) IDReturns(result1 int) {
	fake.IDStub = nil
	fake.iDReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeTeam) IDReturnsOnCall(i int, result1 int) {
	fake.IDStub = nil
	if fake.iDReturnsOnCall == nil {
		fake.iDReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.iDReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeTeam) Name() string {
	fake.nameMutex.Lock()
	ret, specificReturn := fake.nameReturnsOnCall[len(fake.nameArgsForCall)]
	fake.nameArgsForCall = append(fake.nameArgsForCall, struct{}{})
	fake.recordInvocation("Name", []interface{}{})
	fake.nameMutex.Unlock()
	if fake.NameStub != nil {
		return fake.NameStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.nameReturns.result1
}

func (fake *FakeTeam) NameCallCount() int {
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	return len(fake.nameArgsForCall)
}

func (fake *FakeTeam) NameReturns(result1 string) {
	fake.NameStub = nil
	fake.nameReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) NameReturnsOnCall(i int, result1 string) {
	fake.NameStub = nil
	if fake.nameReturnsOnCall == nil {
		fake.nameReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.nameReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeTeam) Admin() bool {
	fake.adminMutex.Lock()
	ret, specificReturn := fake.adminReturnsOnCall[len(fake.adminArgsForCall)]
	fake.adminArgsForCall = append(fake.adminArgsForCall, struct{}{})
	fake.recordInvocation("Admin", []interface{}{})
	fake.adminMutex.Unlock()
	if fake.AdminStub != nil {
		return fake.AdminStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.adminReturns.result1
}

func (fake *FakeTeam) AdminCallCount() int {
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	return len(fake.adminArgsForCall)
}

func (fake *FakeTeam) AdminReturns(result1 bool) {
	fake.AdminStub = nil
	fake.adminReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTeam) AdminReturnsOnCall(i int, result1 bool) {
	fake.AdminStub = nil
	if fake.adminReturnsOnCall == nil {
		fake.adminReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.adminReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeTeam) BasicAuth() *atc.BasicAuth {
	fake.basicAuthMutex.Lock()
	ret, specificReturn := fake.basicAuthReturnsOnCall[len(fake.basicAuthArgsForCall)]
	fake.basicAuthArgsForCall = append(fake.basicAuthArgsForCall, struct{}{})
	fake.recordInvocation("BasicAuth", []interface{}{})
	fake.basicAuthMutex.Unlock()
	if fake.BasicAuthStub != nil {
		return fake.BasicAuthStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.basicAuthReturns.result1
}

func (fake *FakeTeam) BasicAuthCallCount() int {
	fake.basicAuthMutex.RLock()
	defer fake.basicAuthMutex.RUnlock()
	return len(fake.basicAuthArgsForCall)
}

func (fake *FakeTeam) BasicAuthReturns(result1 *atc.BasicAuth) {
	fake.BasicAuthStub = nil
	fake.basicAuthReturns = struct {
		result1 *atc.BasicAuth
	}{result1}
}

func (fake *FakeTeam) BasicAuthReturnsOnCall(i int, result1 *atc.BasicAuth) {
	fake.BasicAuthStub = nil
	if fake.basicAuthReturnsOnCall == nil {
		fake.basicAuthReturnsOnCall = make(map[int]struct {
			result1 *atc.BasicAuth
		})
	}
	fake.basicAuthReturnsOnCall[i] = struct {
		result1 *atc.BasicAuth
	}{result1}
}

func (fake *FakeTeam) Auth() map[string]*json.RawMessage {
	fake.authMutex.Lock()
	ret, specificReturn := fake.authReturnsOnCall[len(fake.authArgsForCall)]
	fake.authArgsForCall = append(fake.authArgsForCall, struct{}{})
	fake.recordInvocation("Auth", []interface{}{})
	fake.authMutex.Unlock()
	if fake.AuthStub != nil {
		return fake.AuthStub()
	}
	if specificReturn {
		return ret.result1
	}
	return fake.authReturns.result1
}

func (fake *FakeTeam) AuthCallCount() int {
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	return len(fake.authArgsForCall)
}

func (fake *FakeTeam) AuthReturns(result1 map[string]*json.RawMessage) {
	fake.AuthStub = nil
	fake.authReturns = struct {
		result1 map[string]*json.RawMessage
	}{result1}
}

func (fake *FakeTeam) AuthReturnsOnCall(i int, result1 map[string]*json.RawMessage) {
	fake.AuthStub = nil
	if fake.authReturnsOnCall == nil {
		fake.authReturnsOnCall = make(map[int]struct {
			result1 map[string]*json.RawMessage
		})
	}
	fake.authReturnsOnCall[i] = struct {
		result1 map[string]*json.RawMessage
	}{result1}
}

func (fake *FakeTeam) SavePipeline(pipelineName string, config atc.Config, from dbng.ConfigVersion, pausedState dbng.PipelinePausedState) (dbng.Pipeline, bool, error) {
	fake.savePipelineMutex.Lock()
	ret, specificReturn := fake.savePipelineReturnsOnCall[len(fake.savePipelineArgsForCall)]
	fake.savePipelineArgsForCall = append(fake.savePipelineArgsForCall, struct {
		pipelineName string
		config       atc.Config
		from         dbng.ConfigVersion
		pausedState  dbng.PipelinePausedState
	}{pipelineName, config, from, pausedState})
	fake.recordInvocation("SavePipeline", []interface{}{pipelineName, config, from, pausedState})
	fake.savePipelineMutex.Unlock()
	if fake.SavePipelineStub != nil {
		return fake.SavePipelineStub(pipelineName, config, from, pausedState)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.savePipelineReturns.result1, fake.savePipelineReturns.result2, fake.savePipelineReturns.result3
}

func (fake *FakeTeam) SavePipelineCallCount() int {
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	return len(fake.savePipelineArgsForCall)
}

func (fake *FakeTeam) SavePipelineArgsForCall(i int) (string, atc.Config, dbng.ConfigVersion, dbng.PipelinePausedState) {
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	return fake.savePipelineArgsForCall[i].pipelineName, fake.savePipelineArgsForCall[i].config, fake.savePipelineArgsForCall[i].from, fake.savePipelineArgsForCall[i].pausedState
}

func (fake *FakeTeam) SavePipelineReturns(result1 dbng.Pipeline, result2 bool, result3 error) {
	fake.SavePipelineStub = nil
	fake.savePipelineReturns = struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) SavePipelineReturnsOnCall(i int, result1 dbng.Pipeline, result2 bool, result3 error) {
	fake.SavePipelineStub = nil
	if fake.savePipelineReturnsOnCall == nil {
		fake.savePipelineReturnsOnCall = make(map[int]struct {
			result1 dbng.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.savePipelineReturnsOnCall[i] = struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindPipelineByName(pipelineName string) (dbng.Pipeline, bool, error) {
	fake.findPipelineByNameMutex.Lock()
	ret, specificReturn := fake.findPipelineByNameReturnsOnCall[len(fake.findPipelineByNameArgsForCall)]
	fake.findPipelineByNameArgsForCall = append(fake.findPipelineByNameArgsForCall, struct {
		pipelineName string
	}{pipelineName})
	fake.recordInvocation("FindPipelineByName", []interface{}{pipelineName})
	fake.findPipelineByNameMutex.Unlock()
	if fake.FindPipelineByNameStub != nil {
		return fake.FindPipelineByNameStub(pipelineName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findPipelineByNameReturns.result1, fake.findPipelineByNameReturns.result2, fake.findPipelineByNameReturns.result3
}

func (fake *FakeTeam) FindPipelineByNameCallCount() int {
	fake.findPipelineByNameMutex.RLock()
	defer fake.findPipelineByNameMutex.RUnlock()
	return len(fake.findPipelineByNameArgsForCall)
}

func (fake *FakeTeam) FindPipelineByNameArgsForCall(i int) string {
	fake.findPipelineByNameMutex.RLock()
	defer fake.findPipelineByNameMutex.RUnlock()
	return fake.findPipelineByNameArgsForCall[i].pipelineName
}

func (fake *FakeTeam) FindPipelineByNameReturns(result1 dbng.Pipeline, result2 bool, result3 error) {
	fake.FindPipelineByNameStub = nil
	fake.findPipelineByNameReturns = struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindPipelineByNameReturnsOnCall(i int, result1 dbng.Pipeline, result2 bool, result3 error) {
	fake.FindPipelineByNameStub = nil
	if fake.findPipelineByNameReturnsOnCall == nil {
		fake.findPipelineByNameReturnsOnCall = make(map[int]struct {
			result1 dbng.Pipeline
			result2 bool
			result3 error
		})
	}
	fake.findPipelineByNameReturnsOnCall[i] = struct {
		result1 dbng.Pipeline
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) CreateOneOffBuild() (dbng.Build, error) {
	fake.createOneOffBuildMutex.Lock()
	ret, specificReturn := fake.createOneOffBuildReturnsOnCall[len(fake.createOneOffBuildArgsForCall)]
	fake.createOneOffBuildArgsForCall = append(fake.createOneOffBuildArgsForCall, struct{}{})
	fake.recordInvocation("CreateOneOffBuild", []interface{}{})
	fake.createOneOffBuildMutex.Unlock()
	if fake.CreateOneOffBuildStub != nil {
		return fake.CreateOneOffBuildStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createOneOffBuildReturns.result1, fake.createOneOffBuildReturns.result2
}

func (fake *FakeTeam) CreateOneOffBuildCallCount() int {
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	return len(fake.createOneOffBuildArgsForCall)
}

func (fake *FakeTeam) CreateOneOffBuildReturns(result1 dbng.Build, result2 error) {
	fake.CreateOneOffBuildStub = nil
	fake.createOneOffBuildReturns = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateOneOffBuildReturnsOnCall(i int, result1 dbng.Build, result2 error) {
	fake.CreateOneOffBuildStub = nil
	if fake.createOneOffBuildReturnsOnCall == nil {
		fake.createOneOffBuildReturnsOnCall = make(map[int]struct {
			result1 dbng.Build
			result2 error
		})
	}
	fake.createOneOffBuildReturnsOnCall[i] = struct {
		result1 dbng.Build
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) SaveWorker(atcWorker atc.Worker, ttl time.Duration) (dbng.Worker, error) {
	fake.saveWorkerMutex.Lock()
	ret, specificReturn := fake.saveWorkerReturnsOnCall[len(fake.saveWorkerArgsForCall)]
	fake.saveWorkerArgsForCall = append(fake.saveWorkerArgsForCall, struct {
		atcWorker atc.Worker
		ttl       time.Duration
	}{atcWorker, ttl})
	fake.recordInvocation("SaveWorker", []interface{}{atcWorker, ttl})
	fake.saveWorkerMutex.Unlock()
	if fake.SaveWorkerStub != nil {
		return fake.SaveWorkerStub(atcWorker, ttl)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.saveWorkerReturns.result1, fake.saveWorkerReturns.result2
}

func (fake *FakeTeam) SaveWorkerCallCount() int {
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	return len(fake.saveWorkerArgsForCall)
}

func (fake *FakeTeam) SaveWorkerArgsForCall(i int) (atc.Worker, time.Duration) {
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	return fake.saveWorkerArgsForCall[i].atcWorker, fake.saveWorkerArgsForCall[i].ttl
}

func (fake *FakeTeam) SaveWorkerReturns(result1 dbng.Worker, result2 error) {
	fake.SaveWorkerStub = nil
	fake.saveWorkerReturns = struct {
		result1 dbng.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) SaveWorkerReturnsOnCall(i int, result1 dbng.Worker, result2 error) {
	fake.SaveWorkerStub = nil
	if fake.saveWorkerReturnsOnCall == nil {
		fake.saveWorkerReturnsOnCall = make(map[int]struct {
			result1 dbng.Worker
			result2 error
		})
	}
	fake.saveWorkerReturnsOnCall[i] = struct {
		result1 dbng.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) Workers() ([]dbng.Worker, error) {
	fake.workersMutex.Lock()
	ret, specificReturn := fake.workersReturnsOnCall[len(fake.workersArgsForCall)]
	fake.workersArgsForCall = append(fake.workersArgsForCall, struct{}{})
	fake.recordInvocation("Workers", []interface{}{})
	fake.workersMutex.Unlock()
	if fake.WorkersStub != nil {
		return fake.WorkersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.workersReturns.result1, fake.workersReturns.result2
}

func (fake *FakeTeam) WorkersCallCount() int {
	fake.workersMutex.RLock()
	defer fake.workersMutex.RUnlock()
	return len(fake.workersArgsForCall)
}

func (fake *FakeTeam) WorkersReturns(result1 []dbng.Worker, result2 error) {
	fake.WorkersStub = nil
	fake.workersReturns = struct {
		result1 []dbng.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) WorkersReturnsOnCall(i int, result1 []dbng.Worker, result2 error) {
	fake.WorkersStub = nil
	if fake.workersReturnsOnCall == nil {
		fake.workersReturnsOnCall = make(map[int]struct {
			result1 []dbng.Worker
			result2 error
		})
	}
	fake.workersReturnsOnCall[i] = struct {
		result1 []dbng.Worker
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) FindContainerByHandle(arg1 string) (dbng.Container, bool, error) {
	fake.findContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findContainerByHandleReturnsOnCall[len(fake.findContainerByHandleArgsForCall)]
	fake.findContainerByHandleArgsForCall = append(fake.findContainerByHandleArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindContainerByHandle", []interface{}{arg1})
	fake.findContainerByHandleMutex.Unlock()
	if fake.FindContainerByHandleStub != nil {
		return fake.FindContainerByHandleStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findContainerByHandleReturns.result1, fake.findContainerByHandleReturns.result2, fake.findContainerByHandleReturns.result3
}

func (fake *FakeTeam) FindContainerByHandleCallCount() int {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return len(fake.findContainerByHandleArgsForCall)
}

func (fake *FakeTeam) FindContainerByHandleArgsForCall(i int) string {
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	return fake.findContainerByHandleArgsForCall[i].arg1
}

func (fake *FakeTeam) FindContainerByHandleReturns(result1 dbng.Container, result2 bool, result3 error) {
	fake.FindContainerByHandleStub = nil
	fake.findContainerByHandleReturns = struct {
		result1 dbng.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindContainerByHandleReturnsOnCall(i int, result1 dbng.Container, result2 bool, result3 error) {
	fake.FindContainerByHandleStub = nil
	if fake.findContainerByHandleReturnsOnCall == nil {
		fake.findContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 dbng.Container
			result2 bool
			result3 error
		})
	}
	fake.findContainerByHandleReturnsOnCall[i] = struct {
		result1 dbng.Container
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindContainersByMetadata(arg1 dbng.ContainerMetadata) ([]dbng.Container, error) {
	fake.findContainersByMetadataMutex.Lock()
	ret, specificReturn := fake.findContainersByMetadataReturnsOnCall[len(fake.findContainersByMetadataArgsForCall)]
	fake.findContainersByMetadataArgsForCall = append(fake.findContainersByMetadataArgsForCall, struct {
		arg1 dbng.ContainerMetadata
	}{arg1})
	fake.recordInvocation("FindContainersByMetadata", []interface{}{arg1})
	fake.findContainersByMetadataMutex.Unlock()
	if fake.FindContainersByMetadataStub != nil {
		return fake.FindContainersByMetadataStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.findContainersByMetadataReturns.result1, fake.findContainersByMetadataReturns.result2
}

func (fake *FakeTeam) FindContainersByMetadataCallCount() int {
	fake.findContainersByMetadataMutex.RLock()
	defer fake.findContainersByMetadataMutex.RUnlock()
	return len(fake.findContainersByMetadataArgsForCall)
}

func (fake *FakeTeam) FindContainersByMetadataArgsForCall(i int) dbng.ContainerMetadata {
	fake.findContainersByMetadataMutex.RLock()
	defer fake.findContainersByMetadataMutex.RUnlock()
	return fake.findContainersByMetadataArgsForCall[i].arg1
}

func (fake *FakeTeam) FindContainersByMetadataReturns(result1 []dbng.Container, result2 error) {
	fake.FindContainersByMetadataStub = nil
	fake.findContainersByMetadataReturns = struct {
		result1 []dbng.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) FindContainersByMetadataReturnsOnCall(i int, result1 []dbng.Container, result2 error) {
	fake.FindContainersByMetadataStub = nil
	if fake.findContainersByMetadataReturnsOnCall == nil {
		fake.findContainersByMetadataReturnsOnCall = make(map[int]struct {
			result1 []dbng.Container
			result2 error
		})
	}
	fake.findContainersByMetadataReturnsOnCall[i] = struct {
		result1 []dbng.Container
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) FindCreatedContainerByHandle(arg1 string) (dbng.CreatedContainer, bool, error) {
	fake.findCreatedContainerByHandleMutex.Lock()
	ret, specificReturn := fake.findCreatedContainerByHandleReturnsOnCall[len(fake.findCreatedContainerByHandleArgsForCall)]
	fake.findCreatedContainerByHandleArgsForCall = append(fake.findCreatedContainerByHandleArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("FindCreatedContainerByHandle", []interface{}{arg1})
	fake.findCreatedContainerByHandleMutex.Unlock()
	if fake.FindCreatedContainerByHandleStub != nil {
		return fake.FindCreatedContainerByHandleStub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findCreatedContainerByHandleReturns.result1, fake.findCreatedContainerByHandleReturns.result2, fake.findCreatedContainerByHandleReturns.result3
}

func (fake *FakeTeam) FindCreatedContainerByHandleCallCount() int {
	fake.findCreatedContainerByHandleMutex.RLock()
	defer fake.findCreatedContainerByHandleMutex.RUnlock()
	return len(fake.findCreatedContainerByHandleArgsForCall)
}

func (fake *FakeTeam) FindCreatedContainerByHandleArgsForCall(i int) string {
	fake.findCreatedContainerByHandleMutex.RLock()
	defer fake.findCreatedContainerByHandleMutex.RUnlock()
	return fake.findCreatedContainerByHandleArgsForCall[i].arg1
}

func (fake *FakeTeam) FindCreatedContainerByHandleReturns(result1 dbng.CreatedContainer, result2 bool, result3 error) {
	fake.FindCreatedContainerByHandleStub = nil
	fake.findCreatedContainerByHandleReturns = struct {
		result1 dbng.CreatedContainer
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindCreatedContainerByHandleReturnsOnCall(i int, result1 dbng.CreatedContainer, result2 bool, result3 error) {
	fake.FindCreatedContainerByHandleStub = nil
	if fake.findCreatedContainerByHandleReturnsOnCall == nil {
		fake.findCreatedContainerByHandleReturnsOnCall = make(map[int]struct {
			result1 dbng.CreatedContainer
			result2 bool
			result3 error
		})
	}
	fake.findCreatedContainerByHandleReturnsOnCall[i] = struct {
		result1 dbng.CreatedContainer
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForResourceCheckContainer(resourceConfig *dbng.UsedResourceConfig) (dbng.Worker, bool, error) {
	fake.findWorkerForResourceCheckContainerMutex.Lock()
	ret, specificReturn := fake.findWorkerForResourceCheckContainerReturnsOnCall[len(fake.findWorkerForResourceCheckContainerArgsForCall)]
	fake.findWorkerForResourceCheckContainerArgsForCall = append(fake.findWorkerForResourceCheckContainerArgsForCall, struct {
		resourceConfig *dbng.UsedResourceConfig
	}{resourceConfig})
	fake.recordInvocation("FindWorkerForResourceCheckContainer", []interface{}{resourceConfig})
	fake.findWorkerForResourceCheckContainerMutex.Unlock()
	if fake.FindWorkerForResourceCheckContainerStub != nil {
		return fake.FindWorkerForResourceCheckContainerStub(resourceConfig)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findWorkerForResourceCheckContainerReturns.result1, fake.findWorkerForResourceCheckContainerReturns.result2, fake.findWorkerForResourceCheckContainerReturns.result3
}

func (fake *FakeTeam) FindWorkerForResourceCheckContainerCallCount() int {
	fake.findWorkerForResourceCheckContainerMutex.RLock()
	defer fake.findWorkerForResourceCheckContainerMutex.RUnlock()
	return len(fake.findWorkerForResourceCheckContainerArgsForCall)
}

func (fake *FakeTeam) FindWorkerForResourceCheckContainerArgsForCall(i int) *dbng.UsedResourceConfig {
	fake.findWorkerForResourceCheckContainerMutex.RLock()
	defer fake.findWorkerForResourceCheckContainerMutex.RUnlock()
	return fake.findWorkerForResourceCheckContainerArgsForCall[i].resourceConfig
}

func (fake *FakeTeam) FindWorkerForResourceCheckContainerReturns(result1 dbng.Worker, result2 bool, result3 error) {
	fake.FindWorkerForResourceCheckContainerStub = nil
	fake.findWorkerForResourceCheckContainerReturns = struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForResourceCheckContainerReturnsOnCall(i int, result1 dbng.Worker, result2 bool, result3 error) {
	fake.FindWorkerForResourceCheckContainerStub = nil
	if fake.findWorkerForResourceCheckContainerReturnsOnCall == nil {
		fake.findWorkerForResourceCheckContainerReturnsOnCall = make(map[int]struct {
			result1 dbng.Worker
			result2 bool
			result3 error
		})
	}
	fake.findWorkerForResourceCheckContainerReturnsOnCall[i] = struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindResourceCheckContainerOnWorker(workerName string, resourceConfig *dbng.UsedResourceConfig) (dbng.CreatingContainer, dbng.CreatedContainer, error) {
	fake.findResourceCheckContainerOnWorkerMutex.Lock()
	ret, specificReturn := fake.findResourceCheckContainerOnWorkerReturnsOnCall[len(fake.findResourceCheckContainerOnWorkerArgsForCall)]
	fake.findResourceCheckContainerOnWorkerArgsForCall = append(fake.findResourceCheckContainerOnWorkerArgsForCall, struct {
		workerName     string
		resourceConfig *dbng.UsedResourceConfig
	}{workerName, resourceConfig})
	fake.recordInvocation("FindResourceCheckContainerOnWorker", []interface{}{workerName, resourceConfig})
	fake.findResourceCheckContainerOnWorkerMutex.Unlock()
	if fake.FindResourceCheckContainerOnWorkerStub != nil {
		return fake.FindResourceCheckContainerOnWorkerStub(workerName, resourceConfig)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findResourceCheckContainerOnWorkerReturns.result1, fake.findResourceCheckContainerOnWorkerReturns.result2, fake.findResourceCheckContainerOnWorkerReturns.result3
}

func (fake *FakeTeam) FindResourceCheckContainerOnWorkerCallCount() int {
	fake.findResourceCheckContainerOnWorkerMutex.RLock()
	defer fake.findResourceCheckContainerOnWorkerMutex.RUnlock()
	return len(fake.findResourceCheckContainerOnWorkerArgsForCall)
}

func (fake *FakeTeam) FindResourceCheckContainerOnWorkerArgsForCall(i int) (string, *dbng.UsedResourceConfig) {
	fake.findResourceCheckContainerOnWorkerMutex.RLock()
	defer fake.findResourceCheckContainerOnWorkerMutex.RUnlock()
	return fake.findResourceCheckContainerOnWorkerArgsForCall[i].workerName, fake.findResourceCheckContainerOnWorkerArgsForCall[i].resourceConfig
}

func (fake *FakeTeam) FindResourceCheckContainerOnWorkerReturns(result1 dbng.CreatingContainer, result2 dbng.CreatedContainer, result3 error) {
	fake.FindResourceCheckContainerOnWorkerStub = nil
	fake.findResourceCheckContainerOnWorkerReturns = struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindResourceCheckContainerOnWorkerReturnsOnCall(i int, result1 dbng.CreatingContainer, result2 dbng.CreatedContainer, result3 error) {
	fake.FindResourceCheckContainerOnWorkerStub = nil
	if fake.findResourceCheckContainerOnWorkerReturnsOnCall == nil {
		fake.findResourceCheckContainerOnWorkerReturnsOnCall = make(map[int]struct {
			result1 dbng.CreatingContainer
			result2 dbng.CreatedContainer
			result3 error
		})
	}
	fake.findResourceCheckContainerOnWorkerReturnsOnCall[i] = struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) CreateResourceCheckContainer(workerName string, resourceConfig *dbng.UsedResourceConfig, meta dbng.ContainerMetadata) (dbng.CreatingContainer, error) {
	fake.createResourceCheckContainerMutex.Lock()
	ret, specificReturn := fake.createResourceCheckContainerReturnsOnCall[len(fake.createResourceCheckContainerArgsForCall)]
	fake.createResourceCheckContainerArgsForCall = append(fake.createResourceCheckContainerArgsForCall, struct {
		workerName     string
		resourceConfig *dbng.UsedResourceConfig
		meta           dbng.ContainerMetadata
	}{workerName, resourceConfig, meta})
	fake.recordInvocation("CreateResourceCheckContainer", []interface{}{workerName, resourceConfig, meta})
	fake.createResourceCheckContainerMutex.Unlock()
	if fake.CreateResourceCheckContainerStub != nil {
		return fake.CreateResourceCheckContainerStub(workerName, resourceConfig, meta)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createResourceCheckContainerReturns.result1, fake.createResourceCheckContainerReturns.result2
}

func (fake *FakeTeam) CreateResourceCheckContainerCallCount() int {
	fake.createResourceCheckContainerMutex.RLock()
	defer fake.createResourceCheckContainerMutex.RUnlock()
	return len(fake.createResourceCheckContainerArgsForCall)
}

func (fake *FakeTeam) CreateResourceCheckContainerArgsForCall(i int) (string, *dbng.UsedResourceConfig, dbng.ContainerMetadata) {
	fake.createResourceCheckContainerMutex.RLock()
	defer fake.createResourceCheckContainerMutex.RUnlock()
	return fake.createResourceCheckContainerArgsForCall[i].workerName, fake.createResourceCheckContainerArgsForCall[i].resourceConfig, fake.createResourceCheckContainerArgsForCall[i].meta
}

func (fake *FakeTeam) CreateResourceCheckContainerReturns(result1 dbng.CreatingContainer, result2 error) {
	fake.CreateResourceCheckContainerStub = nil
	fake.createResourceCheckContainerReturns = struct {
		result1 dbng.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateResourceCheckContainerReturnsOnCall(i int, result1 dbng.CreatingContainer, result2 error) {
	fake.CreateResourceCheckContainerStub = nil
	if fake.createResourceCheckContainerReturnsOnCall == nil {
		fake.createResourceCheckContainerReturnsOnCall = make(map[int]struct {
			result1 dbng.CreatingContainer
			result2 error
		})
	}
	fake.createResourceCheckContainerReturnsOnCall[i] = struct {
		result1 dbng.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateResourceGetContainer(workerName string, resourceConfig *dbng.UsedResourceCache, meta dbng.ContainerMetadata) (dbng.CreatingContainer, error) {
	fake.createResourceGetContainerMutex.Lock()
	ret, specificReturn := fake.createResourceGetContainerReturnsOnCall[len(fake.createResourceGetContainerArgsForCall)]
	fake.createResourceGetContainerArgsForCall = append(fake.createResourceGetContainerArgsForCall, struct {
		workerName     string
		resourceConfig *dbng.UsedResourceCache
		meta           dbng.ContainerMetadata
	}{workerName, resourceConfig, meta})
	fake.recordInvocation("CreateResourceGetContainer", []interface{}{workerName, resourceConfig, meta})
	fake.createResourceGetContainerMutex.Unlock()
	if fake.CreateResourceGetContainerStub != nil {
		return fake.CreateResourceGetContainerStub(workerName, resourceConfig, meta)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createResourceGetContainerReturns.result1, fake.createResourceGetContainerReturns.result2
}

func (fake *FakeTeam) CreateResourceGetContainerCallCount() int {
	fake.createResourceGetContainerMutex.RLock()
	defer fake.createResourceGetContainerMutex.RUnlock()
	return len(fake.createResourceGetContainerArgsForCall)
}

func (fake *FakeTeam) CreateResourceGetContainerArgsForCall(i int) (string, *dbng.UsedResourceCache, dbng.ContainerMetadata) {
	fake.createResourceGetContainerMutex.RLock()
	defer fake.createResourceGetContainerMutex.RUnlock()
	return fake.createResourceGetContainerArgsForCall[i].workerName, fake.createResourceGetContainerArgsForCall[i].resourceConfig, fake.createResourceGetContainerArgsForCall[i].meta
}

func (fake *FakeTeam) CreateResourceGetContainerReturns(result1 dbng.CreatingContainer, result2 error) {
	fake.CreateResourceGetContainerStub = nil
	fake.createResourceGetContainerReturns = struct {
		result1 dbng.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateResourceGetContainerReturnsOnCall(i int, result1 dbng.CreatingContainer, result2 error) {
	fake.CreateResourceGetContainerStub = nil
	if fake.createResourceGetContainerReturnsOnCall == nil {
		fake.createResourceGetContainerReturnsOnCall = make(map[int]struct {
			result1 dbng.CreatingContainer
			result2 error
		})
	}
	fake.createResourceGetContainerReturnsOnCall[i] = struct {
		result1 dbng.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) FindWorkerForContainer(handle string) (dbng.Worker, bool, error) {
	fake.findWorkerForContainerMutex.Lock()
	ret, specificReturn := fake.findWorkerForContainerReturnsOnCall[len(fake.findWorkerForContainerArgsForCall)]
	fake.findWorkerForContainerArgsForCall = append(fake.findWorkerForContainerArgsForCall, struct {
		handle string
	}{handle})
	fake.recordInvocation("FindWorkerForContainer", []interface{}{handle})
	fake.findWorkerForContainerMutex.Unlock()
	if fake.FindWorkerForContainerStub != nil {
		return fake.FindWorkerForContainerStub(handle)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findWorkerForContainerReturns.result1, fake.findWorkerForContainerReturns.result2, fake.findWorkerForContainerReturns.result3
}

func (fake *FakeTeam) FindWorkerForContainerCallCount() int {
	fake.findWorkerForContainerMutex.RLock()
	defer fake.findWorkerForContainerMutex.RUnlock()
	return len(fake.findWorkerForContainerArgsForCall)
}

func (fake *FakeTeam) FindWorkerForContainerArgsForCall(i int) string {
	fake.findWorkerForContainerMutex.RLock()
	defer fake.findWorkerForContainerMutex.RUnlock()
	return fake.findWorkerForContainerArgsForCall[i].handle
}

func (fake *FakeTeam) FindWorkerForContainerReturns(result1 dbng.Worker, result2 bool, result3 error) {
	fake.FindWorkerForContainerStub = nil
	fake.findWorkerForContainerReturns = struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForContainerReturnsOnCall(i int, result1 dbng.Worker, result2 bool, result3 error) {
	fake.FindWorkerForContainerStub = nil
	if fake.findWorkerForContainerReturnsOnCall == nil {
		fake.findWorkerForContainerReturnsOnCall = make(map[int]struct {
			result1 dbng.Worker
			result2 bool
			result3 error
		})
	}
	fake.findWorkerForContainerReturnsOnCall[i] = struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForBuildContainer(buildID int, planID atc.PlanID) (dbng.Worker, bool, error) {
	fake.findWorkerForBuildContainerMutex.Lock()
	ret, specificReturn := fake.findWorkerForBuildContainerReturnsOnCall[len(fake.findWorkerForBuildContainerArgsForCall)]
	fake.findWorkerForBuildContainerArgsForCall = append(fake.findWorkerForBuildContainerArgsForCall, struct {
		buildID int
		planID  atc.PlanID
	}{buildID, planID})
	fake.recordInvocation("FindWorkerForBuildContainer", []interface{}{buildID, planID})
	fake.findWorkerForBuildContainerMutex.Unlock()
	if fake.FindWorkerForBuildContainerStub != nil {
		return fake.FindWorkerForBuildContainerStub(buildID, planID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findWorkerForBuildContainerReturns.result1, fake.findWorkerForBuildContainerReturns.result2, fake.findWorkerForBuildContainerReturns.result3
}

func (fake *FakeTeam) FindWorkerForBuildContainerCallCount() int {
	fake.findWorkerForBuildContainerMutex.RLock()
	defer fake.findWorkerForBuildContainerMutex.RUnlock()
	return len(fake.findWorkerForBuildContainerArgsForCall)
}

func (fake *FakeTeam) FindWorkerForBuildContainerArgsForCall(i int) (int, atc.PlanID) {
	fake.findWorkerForBuildContainerMutex.RLock()
	defer fake.findWorkerForBuildContainerMutex.RUnlock()
	return fake.findWorkerForBuildContainerArgsForCall[i].buildID, fake.findWorkerForBuildContainerArgsForCall[i].planID
}

func (fake *FakeTeam) FindWorkerForBuildContainerReturns(result1 dbng.Worker, result2 bool, result3 error) {
	fake.FindWorkerForBuildContainerStub = nil
	fake.findWorkerForBuildContainerReturns = struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindWorkerForBuildContainerReturnsOnCall(i int, result1 dbng.Worker, result2 bool, result3 error) {
	fake.FindWorkerForBuildContainerStub = nil
	if fake.findWorkerForBuildContainerReturnsOnCall == nil {
		fake.findWorkerForBuildContainerReturnsOnCall = make(map[int]struct {
			result1 dbng.Worker
			result2 bool
			result3 error
		})
	}
	fake.findWorkerForBuildContainerReturnsOnCall[i] = struct {
		result1 dbng.Worker
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindBuildContainerOnWorker(workerName string, buildID int, planID atc.PlanID) (dbng.CreatingContainer, dbng.CreatedContainer, error) {
	fake.findBuildContainerOnWorkerMutex.Lock()
	ret, specificReturn := fake.findBuildContainerOnWorkerReturnsOnCall[len(fake.findBuildContainerOnWorkerArgsForCall)]
	fake.findBuildContainerOnWorkerArgsForCall = append(fake.findBuildContainerOnWorkerArgsForCall, struct {
		workerName string
		buildID    int
		planID     atc.PlanID
	}{workerName, buildID, planID})
	fake.recordInvocation("FindBuildContainerOnWorker", []interface{}{workerName, buildID, planID})
	fake.findBuildContainerOnWorkerMutex.Unlock()
	if fake.FindBuildContainerOnWorkerStub != nil {
		return fake.FindBuildContainerOnWorkerStub(workerName, buildID, planID)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fake.findBuildContainerOnWorkerReturns.result1, fake.findBuildContainerOnWorkerReturns.result2, fake.findBuildContainerOnWorkerReturns.result3
}

func (fake *FakeTeam) FindBuildContainerOnWorkerCallCount() int {
	fake.findBuildContainerOnWorkerMutex.RLock()
	defer fake.findBuildContainerOnWorkerMutex.RUnlock()
	return len(fake.findBuildContainerOnWorkerArgsForCall)
}

func (fake *FakeTeam) FindBuildContainerOnWorkerArgsForCall(i int) (string, int, atc.PlanID) {
	fake.findBuildContainerOnWorkerMutex.RLock()
	defer fake.findBuildContainerOnWorkerMutex.RUnlock()
	return fake.findBuildContainerOnWorkerArgsForCall[i].workerName, fake.findBuildContainerOnWorkerArgsForCall[i].buildID, fake.findBuildContainerOnWorkerArgsForCall[i].planID
}

func (fake *FakeTeam) FindBuildContainerOnWorkerReturns(result1 dbng.CreatingContainer, result2 dbng.CreatedContainer, result3 error) {
	fake.FindBuildContainerOnWorkerStub = nil
	fake.findBuildContainerOnWorkerReturns = struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) FindBuildContainerOnWorkerReturnsOnCall(i int, result1 dbng.CreatingContainer, result2 dbng.CreatedContainer, result3 error) {
	fake.FindBuildContainerOnWorkerStub = nil
	if fake.findBuildContainerOnWorkerReturnsOnCall == nil {
		fake.findBuildContainerOnWorkerReturnsOnCall = make(map[int]struct {
			result1 dbng.CreatingContainer
			result2 dbng.CreatedContainer
			result3 error
		})
	}
	fake.findBuildContainerOnWorkerReturnsOnCall[i] = struct {
		result1 dbng.CreatingContainer
		result2 dbng.CreatedContainer
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeTeam) CreateBuildContainer(workerName string, buildID int, planID atc.PlanID, meta dbng.ContainerMetadata) (dbng.CreatingContainer, error) {
	fake.createBuildContainerMutex.Lock()
	ret, specificReturn := fake.createBuildContainerReturnsOnCall[len(fake.createBuildContainerArgsForCall)]
	fake.createBuildContainerArgsForCall = append(fake.createBuildContainerArgsForCall, struct {
		workerName string
		buildID    int
		planID     atc.PlanID
		meta       dbng.ContainerMetadata
	}{workerName, buildID, planID, meta})
	fake.recordInvocation("CreateBuildContainer", []interface{}{workerName, buildID, planID, meta})
	fake.createBuildContainerMutex.Unlock()
	if fake.CreateBuildContainerStub != nil {
		return fake.CreateBuildContainerStub(workerName, buildID, planID, meta)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createBuildContainerReturns.result1, fake.createBuildContainerReturns.result2
}

func (fake *FakeTeam) CreateBuildContainerCallCount() int {
	fake.createBuildContainerMutex.RLock()
	defer fake.createBuildContainerMutex.RUnlock()
	return len(fake.createBuildContainerArgsForCall)
}

func (fake *FakeTeam) CreateBuildContainerArgsForCall(i int) (string, int, atc.PlanID, dbng.ContainerMetadata) {
	fake.createBuildContainerMutex.RLock()
	defer fake.createBuildContainerMutex.RUnlock()
	return fake.createBuildContainerArgsForCall[i].workerName, fake.createBuildContainerArgsForCall[i].buildID, fake.createBuildContainerArgsForCall[i].planID, fake.createBuildContainerArgsForCall[i].meta
}

func (fake *FakeTeam) CreateBuildContainerReturns(result1 dbng.CreatingContainer, result2 error) {
	fake.CreateBuildContainerStub = nil
	fake.createBuildContainerReturns = struct {
		result1 dbng.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) CreateBuildContainerReturnsOnCall(i int, result1 dbng.CreatingContainer, result2 error) {
	fake.CreateBuildContainerStub = nil
	if fake.createBuildContainerReturnsOnCall == nil {
		fake.createBuildContainerReturnsOnCall = make(map[int]struct {
			result1 dbng.CreatingContainer
			result2 error
		})
	}
	fake.createBuildContainerReturnsOnCall[i] = struct {
		result1 dbng.CreatingContainer
		result2 error
	}{result1, result2}
}

func (fake *FakeTeam) UpdateBasicAuth(basicAuth *atc.BasicAuth) error {
	fake.updateBasicAuthMutex.Lock()
	ret, specificReturn := fake.updateBasicAuthReturnsOnCall[len(fake.updateBasicAuthArgsForCall)]
	fake.updateBasicAuthArgsForCall = append(fake.updateBasicAuthArgsForCall, struct {
		basicAuth *atc.BasicAuth
	}{basicAuth})
	fake.recordInvocation("UpdateBasicAuth", []interface{}{basicAuth})
	fake.updateBasicAuthMutex.Unlock()
	if fake.UpdateBasicAuthStub != nil {
		return fake.UpdateBasicAuthStub(basicAuth)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateBasicAuthReturns.result1
}

func (fake *FakeTeam) UpdateBasicAuthCallCount() int {
	fake.updateBasicAuthMutex.RLock()
	defer fake.updateBasicAuthMutex.RUnlock()
	return len(fake.updateBasicAuthArgsForCall)
}

func (fake *FakeTeam) UpdateBasicAuthArgsForCall(i int) *atc.BasicAuth {
	fake.updateBasicAuthMutex.RLock()
	defer fake.updateBasicAuthMutex.RUnlock()
	return fake.updateBasicAuthArgsForCall[i].basicAuth
}

func (fake *FakeTeam) UpdateBasicAuthReturns(result1 error) {
	fake.UpdateBasicAuthStub = nil
	fake.updateBasicAuthReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) UpdateBasicAuthReturnsOnCall(i int, result1 error) {
	fake.UpdateBasicAuthStub = nil
	if fake.updateBasicAuthReturnsOnCall == nil {
		fake.updateBasicAuthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateBasicAuthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) UpdateProviderAuth(auth map[string]*json.RawMessage) error {
	fake.updateProviderAuthMutex.Lock()
	ret, specificReturn := fake.updateProviderAuthReturnsOnCall[len(fake.updateProviderAuthArgsForCall)]
	fake.updateProviderAuthArgsForCall = append(fake.updateProviderAuthArgsForCall, struct {
		auth map[string]*json.RawMessage
	}{auth})
	fake.recordInvocation("UpdateProviderAuth", []interface{}{auth})
	fake.updateProviderAuthMutex.Unlock()
	if fake.UpdateProviderAuthStub != nil {
		return fake.UpdateProviderAuthStub(auth)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.updateProviderAuthReturns.result1
}

func (fake *FakeTeam) UpdateProviderAuthCallCount() int {
	fake.updateProviderAuthMutex.RLock()
	defer fake.updateProviderAuthMutex.RUnlock()
	return len(fake.updateProviderAuthArgsForCall)
}

func (fake *FakeTeam) UpdateProviderAuthArgsForCall(i int) map[string]*json.RawMessage {
	fake.updateProviderAuthMutex.RLock()
	defer fake.updateProviderAuthMutex.RUnlock()
	return fake.updateProviderAuthArgsForCall[i].auth
}

func (fake *FakeTeam) UpdateProviderAuthReturns(result1 error) {
	fake.UpdateProviderAuthStub = nil
	fake.updateProviderAuthReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) UpdateProviderAuthReturnsOnCall(i int, result1 error) {
	fake.UpdateProviderAuthStub = nil
	if fake.updateProviderAuthReturnsOnCall == nil {
		fake.updateProviderAuthReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateProviderAuthReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeTeam) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.iDMutex.RLock()
	defer fake.iDMutex.RUnlock()
	fake.nameMutex.RLock()
	defer fake.nameMutex.RUnlock()
	fake.adminMutex.RLock()
	defer fake.adminMutex.RUnlock()
	fake.basicAuthMutex.RLock()
	defer fake.basicAuthMutex.RUnlock()
	fake.authMutex.RLock()
	defer fake.authMutex.RUnlock()
	fake.savePipelineMutex.RLock()
	defer fake.savePipelineMutex.RUnlock()
	fake.findPipelineByNameMutex.RLock()
	defer fake.findPipelineByNameMutex.RUnlock()
	fake.createOneOffBuildMutex.RLock()
	defer fake.createOneOffBuildMutex.RUnlock()
	fake.saveWorkerMutex.RLock()
	defer fake.saveWorkerMutex.RUnlock()
	fake.workersMutex.RLock()
	defer fake.workersMutex.RUnlock()
	fake.findContainerByHandleMutex.RLock()
	defer fake.findContainerByHandleMutex.RUnlock()
	fake.findContainersByMetadataMutex.RLock()
	defer fake.findContainersByMetadataMutex.RUnlock()
	fake.findCreatedContainerByHandleMutex.RLock()
	defer fake.findCreatedContainerByHandleMutex.RUnlock()
	fake.findWorkerForResourceCheckContainerMutex.RLock()
	defer fake.findWorkerForResourceCheckContainerMutex.RUnlock()
	fake.findResourceCheckContainerOnWorkerMutex.RLock()
	defer fake.findResourceCheckContainerOnWorkerMutex.RUnlock()
	fake.createResourceCheckContainerMutex.RLock()
	defer fake.createResourceCheckContainerMutex.RUnlock()
	fake.createResourceGetContainerMutex.RLock()
	defer fake.createResourceGetContainerMutex.RUnlock()
	fake.findWorkerForContainerMutex.RLock()
	defer fake.findWorkerForContainerMutex.RUnlock()
	fake.findWorkerForBuildContainerMutex.RLock()
	defer fake.findWorkerForBuildContainerMutex.RUnlock()
	fake.findBuildContainerOnWorkerMutex.RLock()
	defer fake.findBuildContainerOnWorkerMutex.RUnlock()
	fake.createBuildContainerMutex.RLock()
	defer fake.createBuildContainerMutex.RUnlock()
	fake.updateBasicAuthMutex.RLock()
	defer fake.updateBasicAuthMutex.RUnlock()
	fake.updateProviderAuthMutex.RLock()
	defer fake.updateProviderAuthMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeTeam) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ dbng.Team = new(FakeTeam)
